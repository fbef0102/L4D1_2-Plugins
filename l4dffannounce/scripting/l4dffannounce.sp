/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#pragma newdecls required //強制1.7以後的新語法

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <multicolors>
#include <left4dhooks>

#define CVAR_FLAGS				FCVAR_NOTIFY
#define MAXENTITIES 2048

public Plugin myinfo = 
{
	name = "L4D FF Announce Plugin",
	author = "Frustian & HarryPotter",
	description = "Adds Friendly Fire Announcements",
	version = "1.7",
	url = "https://steamcommunity.com/profiles/76561198026784913"
}
//cvar handles
ConVar FFenabled;
ConVar AnnounceType;

//Various global variables
int DamageCache[MAXPLAYERS+1][MAXPLAYERS+1]; //Used to temporarily store Friendly Fire Damage between teammates
Handle FFTimer[MAXPLAYERS+1]; //Used to be able to disable the FF timer when they do more FF

//bool g_bLate;
public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max) 
{
	EngineVersion test = GetEngineVersion();
	
	if( test != Engine_Left4Dead2 && test != Engine_Left4Dead) 
	{
		strcopy(error, err_max, "Plugin only supports Left 4 Dead 1 & 2.");
		return APLRes_SilentFailure;
	}

	//g_bLate = late;
	return APLRes_Success; 
}

public void OnPluginStart()
{
	FFenabled = CreateConVar("l4d_ff_announce_enable", "1", "Enable Announcing Friendly Fire",CVAR_FLAGS);
	AnnounceType = CreateConVar("l4d_ff_announce_type", "1", "Changes how ff announce displays FF damage (1:In chat; 2: In Hint Box; 3: In center text)",CVAR_FLAGS);
	
	HookEvent("player_hurt_concise", Event_HurtConcise, EventHookMode_Post);
	HookEvent("player_incapacitated_start", Event_IncapacitatedStart);

	HookEvent("player_death", Event_PlayerDeath);
	HookEvent("round_end",				Event_RoundEnd,		EventHookMode_PostNoCopy); //trigger twice in versus mode, one when all survivors wipe out or make it to saferom, one when first round ends (second round_start begins).
	HookEvent("map_transition", 		Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors make it to saferoom, and server is about to change next level in coop mode (does not trigger round_end) 
	HookEvent("mission_lost", 			Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors wipe out in coop mode (also triggers round_end)
	HookEvent("finale_vehicle_leaving", Event_RoundEnd,		EventHookMode_PostNoCopy); //final map final rescue vehicle leaving  (does not trigger round_end)
	
	//Autoconfig for plugin
	AutoExecConfig(true, "l4dffannounce");

	// if(g_bLate)
	// {
	// 	for(int i = 1; i <= MaxClients; i++)
	// 	{
	// 		if(IsClientInGame(i)) OnClientPutInServer(i);
	// 	}
	// }
}

public void OnMapEnd()
{
	ResetTimer();
}

// public void OnClientPutInServer(int client)
// {
// 	SDKHook(client, SDKHook_OnTakeDamagePost, OnTakeDamagePost);
// }

public void Event_RoundEnd(Event event, const char[] name, bool dontBroadcast) 
{
	ResetTimer();
}

public void Event_PlayerDeath(Event event, const char[] name, bool dontBroadcast) 
{
	int victim = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));
	if ( !victim || !IsClientInGame(victim) || attacker == victim ) return;
	if ( !attacker || !IsClientInGame(attacker) ) return;

	if(GetClientTeam(attacker) == 2 && GetClientTeam(victim) == 2) //人類 kill &友傷
	{
		CPrintToChatAll("{green}[提示] {lightgreen}%N {default}星爆氣流斬 {olive}%N{default}.",attacker, victim);
	}	
}


public void Event_HurtConcise(Event event, const char[] name, bool dontBroadcast) 
{
	int attacker = event.GetInt("attackerentid");
	int victim = GetClientOfUserId(event.GetInt("userid"));
	if (FFenabled.BoolValue == false || 
	attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  
	
	int damage = event.GetInt("dmg_health");
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

public void Event_IncapacitatedStart(Event event, const char[] name, bool dontBroadcast) 
{
	int victim = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));

	if (FFenabled.BoolValue == false || 
	attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  

	int damage = GetClientHealth(victim) + RoundToFloor(GetTempHealth(victim));
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

// public void OnTakeDamagePost( int victim, int attacker, int inflictor, float fDamage, int damageType) {
// 	if (FFenabled.BoolValue == false || 
//		attacker == victim ||
// 		attacker > MaxClients || attacker < 1 || 
// 		!IsClientInGame(attacker)  || 
// 		IsFakeClient(attacker) || 
// 		GetClientTeam(attacker) != 2 || 
// 		!IsClientInGame(victim) || 
// 		GetClientTeam(victim) != 2)
// 		return; 

// 	if(IsClientInGodFrame(victim)) return;
	
// 	int damage = RoundToFloor(fDamage);
// 	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
// 	{
// 		DamageCache[attacker][victim] += damage;
// 		delete FFTimer[attacker];
// 		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
// 	}
// 	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
// 	{
// 		DamageCache[attacker][victim] = damage;
// 		delete FFTimer[attacker];
// 		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
// 		for (int i = 1; i <= MaxClients; i++)
// 		{
// 			if (i != attacker && i != victim)
// 			{
// 				DamageCache[attacker][i] = 0;
// 			}
// 		}
// 	}
// }

public Action AnnounceFF(Handle timer, int attackerc) //Called if the attacker did not friendly fire recently, and announces all FF they did
{
	char victim[128];
	char attacker[128];

	if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
		GetClientName(attackerc, attacker, sizeof(attacker));
	else
		attacker = "Disconnected Player";

	for (int i = 1; i <= MaxClients; i++)
	{
		if (DamageCache[attackerc][i] != 0 && attackerc != i)
		{
			if (IsClientInGame(i))
			{
				GetClientName(i, victim, sizeof(victim));
				switch(AnnounceType.IntValue)
				{
					case 1:
					{
						if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
							PrintToChat(attackerc, "\x01[\x05TS\x01] \x01你剛造成 \x04%d \x01滴血給 \x03%s\x01.",DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && !IsFakeClient(i))
							PrintToChat(i, "\x01[\x05TS\x01] \x03%s \x01造成了 \x04%d \x01滴血給你.",attacker,DamageCache[attackerc][i]);
					}
					case 2:
					{
						if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
							PrintHintText(attackerc, "\x01你剛射 \x04%d \x01滴血給 \x03%s",DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && !IsFakeClient(i))
							PrintHintText(i, "\x03%s \x01射了 \x04%d \x01滴血給你",attacker,DamageCache[attackerc][i]);
					}
					case 3:
					{
						if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
							PrintCenterText(attackerc, "\x01你剛射 \x04%d \x01滴血給 \x03%s",DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && !IsFakeClient(i))
							PrintCenterText(i, "\x03%s \x01射了 \x04%d \x01滴血給你",attacker,DamageCache[attackerc][i]);
					}
				}
			}
			DamageCache[attackerc][i] = 0;
		}
	}

	FFTimer[attackerc] = null;
	return Plugin_Continue;
}

void ResetTimer()
{
	for (int i = 1; i <= MaxClients; i++)
	{
		delete FFTimer[i];
	}
}

stock bool IsClientInGodFrame( int client )
{
	CountdownTimer timer = L4D2Direct_GetInvulnerabilityTimer(client);
	if(timer == CTimer_Null) return false;

	return (CTimer_GetRemainingTime(timer) > 0.0);
}

stock float GetTempHealth(int client)
{
	static float fCvarDecayRate = -1.0;

	if (fCvarDecayRate == -1.0)
		fCvarDecayRate = FindConVar("pain_pills_decay_rate").FloatValue;

	float fTempHealth = GetEntPropFloat(client, Prop_Send, "m_healthBuffer");
	fTempHealth -= (GetGameTime() - GetEntPropFloat(client, Prop_Send, "m_healthBufferTime")) * fCvarDecayRate;
	return fTempHealth < 0.0 ? 0.0 : fTempHealth;
}
